# Linearizability Verifier (Lowe-Style, Java Port)

This document describes the Lowe-style Linearizability Verifier implemented in **Java**.
It was ported from the original **Scala/Ox Linearizability Testing Framework**
(`JITLinUndoTester`, `SharedLog`, `SeqUndoableQueue`, etc.).

---

## Overview

The verifier checks whether a concurrent history of operations over a shared object
is **linearizable** with respect to a sequential specification.
It is based on the *Just-In-Time Tree Search with Undo* algorithm by **Gavin Lowe**,
adapted for Java.

---

## Key Properties

- Works incrementally (supports partial histories with pending operations)
- Uses an undoable sequential specification to backtrack efficiently
- Analyzes histories generated by either:
  - the built-in **SharedLog** testing framework, or
  - the **snapshot mechanism** (`CollectFAInc` / `Snapshot`)

---

## Architecture Components

| **Component**             | **Description** |
|----------------------------|-----------------|
| `Undoable`                | Interface defining an `undo()` operation for reversible specs |
| `SeqUndoableQueue`        | Sequential FIFO queue implementation with undo support |
| `Event`, `InvokeEvent`, `ReturnEvent` | Event representations of invocations and responses |
| `GenericThreadLog`        | Per-thread log abstraction for building histories |
| `SharedLog`               | Shared, thread-safe log combining events from multiple threads |
| `UndoConfig`              | Internal helper that tracks per-thread pending and returned states |
| `JITLinUndoTester`        | Main Lowe-style linearizability solver |
| `SnapshotJITQueueChecker` | Adapter that connects the snapshot mechanism (`CollectFAInc` / `Snapshot`) |
| `ScriptedQueueTester`     | Example showing scripted (non-concurrent) history verification |

---

## Workflow

1. **Generate a History**
   - Either via `SharedLog` (during controlled tests)
   - Or using a distributed snapshot (`CollectFAInc` / `Snapshot`)

2. **Build Sequential Operations**
   - Translate invocation strings (e.g., `"op offer(obj-5)"`) into corresponding
     `Function<SeqUndoableQueue, Object>` sequential operations.

3. **Run the Verifier**
   - Provide the recorded events to `JITLinUndoTester`.
   - The solver applies each operation sequentially, exploring possible interleavings.
   - It uses `undo()` to backtrack and search for valid linearizations.

---

## Interpreting the Result

> **> 0:** The history is linearizable
> **≤ 0:** The history violates linearizability or the search was exhausted

---

## Implementation Details

### 1. Sequential Specification — `SeqUndoableQueue`

Implements a simple queue with reversible state transitions.

```java
public class SeqUndoableQueue implements Undoable {
    public void enqueue(Object x) { ... }
    public Object dequeue() { ... }
    public void undo() { ... }
}
```

### 2. Solver — JITLinUndoTester
Core of the verifier. Performs a depth-first backtracking exploration of possible linearizations.

### 3. Integration — SnapshotJITQueueChecker

Connects the snapshot mechanism (`CollectFAInc` / `Snapshot`).

Performs the following steps:
- Reads ordered events from `snapshot.scanAll()`.
- Sorts events by counter (stable sort).
- Pairs each invocation (`"op ..."`) with its corresponding return value.
- Maps supported operations (`offer`, `poll`, `dequeue`) to `SeqUndoableQueue`.
- Ignores unsupported operations (`size`, `peek`, `stream`, etc.).
- Executes `JITLinUndoTester` to verify the linearizability of the observed prefix.
- Supports pending operations, enabling verification during runtime.

### 4. Example — ScriptedQueueTester (By hand)
Minimal example demonstrating how to construct and verify a history:
```java
List<List<Step>> script = List.of(
    List.of(new Enq(2), new Deq(2)),
    List.of(new Deq(null), new Enq(3), new Deq(3))
);
int res = ScriptedQueueTester.run(script, true);
```

### Runtime Integration
When integrated into your distributed runtime verifier:
- Wrapper executes actual operations on the concurrent object.
- CollectFAInc logs invocations and responses.
- Verifier periodically reads snapshot.scanAll().
- SnapshotJITQueueChecker reconstructs a partial history.
- JITLinUndoTester checks linearizability “up to now”.

✅ Allows on-the-fly runtime verification without halting the system.
```
Example Output
⚠️ Ignoring unsupported op in spec: op size(null)
⚠️ Ignoring unsupported op in spec: op peek(null)
=== History translated for JITLinUndoTester ===
✅ Historia linealizable (según SeqUndoableQueue).
If a violation occurs:
❌ Historia NO linealizable.
Error found
Invoke(t=0, msg=enqueue(2))
Return(t=1, result=3)
...
```

## Extending the Verifier
- **Adding More Operations**
-- Update SnapshotJITQueueChecker.buildSeqOp() to map operation names:
-- case "peek": return q -> q.peek();
-- case "size": return q -> q.size();
-- Extend SeqUndoableQueue accordingly.
- **Changing the Sequential Specification**
-- Replace SeqUndoableQueue with any Undoable object representing your sequential spec (e.g., SeqUndoableStack, SeqUndoableSet).
- **Integrating with Your Framework**
- You can call the verifier directly from your Verifier class:
```java
int res = SnapshotJITQueueChecker.checkQueueHistory(snapshot, processes, true);
if (res <= 0)
    LOGGER.error("Non-linearizable prefix detected.");
else
    LOGGER.info("Prefix is linearizable so far.");
```

# Run the scripted queue example
```bash
java -cp "target/classes:$(mvn dependency:build-classpath -Dmdep.outputFile=/dev/stdout -q)" ScriptedQueueTester
```


# Run the snapshot-based verifier
```bash
mvn exec:java
```

## Verification Semantics
| **Feature**               | **Supported** | **Notes**                           |
|----------------------------|---------------|-------------------------------------|
| Pending operations         | ✅             | Ignored until response appears      |
| Partial histories          | ✅             | Checks prefix linearizability       |
| Undo-based backtracking    | ✅             | Uses reversible sequential spec     |
| Timeout control            | ✅             | Via `maxSize` parameter             |
| Complex APIs               | ⚠️             | Requires mapping in `buildSeqOp()`  |


## Maintenance Guidelines
-- Adding a New Specification
-- Create a class implementing Undoable.
-- Implement the sequential behavior + undo().
-- Update SnapshotJITQueueChecker.buildSeqOp mappings.
-- Adding New Concurrent Structures
-- Create a test driver (similar to LockFreeQueueJIT).
-- Instantiate SharedLog with your structure.
-- Use the same verification pipeline.

# References

- **Lowe, Gavin.** *Testing for Linearizability.*
  *Concurrency and Computation: Practice and Experience,* Vol. 29, No. 4, Article e3928, 2017.
  ISSN: 1532-0626.
  [https://doi.org/10.1002/cpe.3928](https://doi.org/10.1002/cpe.3928)

- **Lowe, Gavin.** *Linearizability Testing Manual.*
  University of Oxford, 2016.
  Available at: [https://www.cs.ox.ac.uk/people/gavin.lowe/LinearizabiltyTesting/manual.pdf](https://www.cs.ox.ac.uk/people/gavin.lowe/LinearizabiltyTesting/manual.pdf)

- **Ox/CADS (Oxford Concurrent Algorithms and Data Structures).**
  *Scala Linearizability Testing Framework.*
  Available at: [http://www.cs.ox.ac.uk/people/gavin.lowe/LinearizabiltyTesting/](http://www.cs.ox.ac.uk/people/gavin.lowe/LinearizabiltyTesting/)
